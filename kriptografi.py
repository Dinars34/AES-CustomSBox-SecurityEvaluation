# -*- coding: utf-8 -*-
"""kriptografi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MXn7WA3WlKB4XmHu6g5r_0YT16TP2hGp
"""

# AES-128 with Multiple Custom S-boxes and Cryptographic Evaluation
# Ready for Google Colab

from typing import List, Tuple, Dict
import numpy as np
from itertools import combinations

# -------------------------
# 1) Define All S-boxes from the paper
# -------------------------

# S-box 4 (Table 4)
SBOX_4 = [
99,109,34,226,133,28,163,9,86,186,220,231,69,40,16,205,
249,125,201,130,250,192,33,90,112,24,128,175,156,224,114,89,
46,117,108,200,54,166,213,153,233,15,244,181,66,216,185,251,
234,214,152,105,212,60,5,252,218,116,162,123,235,39,126,253,
197,146,104,11,228,76,240,95,143,25,199,145,56,148,88,29,
96,72,85,139,168,154,78,31,243,22,190,198,14,110,47,169,
167,84,255,21,158,129,102,242,254,202,138,93,80,150,172,32,
191,111,174,82,131,115,41,10,97,193,7,71,171,170,106,120,
118,149,155,100,160,211,17,36,230,208,178,121,236,127,59,157,
83,77,94,103,119,8,92,221,206,187,222,20,184,79,26,232,
164,137,246,245,62,53,23,144,134,151,159,140,179,12,27,61,
43,38,217,124,141,247,177,207,147,48,229,4,3,13,64,42,
1,210,248,183,107,63,30,57,219,136,18,91,225,142,237,2,
173,73,241,51,209,101,58,74,188,6,223,49,194,182,132,67,
75,37,35,68,195,55,189,227,19,180,45,52,70,0,215,87,
98,176,50,122,81,196,113,44,65,204,135,165,161,239,238,203
]

# S-box 44 (Table 5) - Already in code
SBOX_44 = [
99,205,85,71,25,127,113,219,63,244,109,159,11,228,94,214,
77,177,201,78,5,48,29,30,87,96,193,80,156,200,216,86,
116,143,10,14,54,169,148,68,49,75,171,157,92,114,188,194,
121,220,131,210,83,135,250,149,253,72,182,33,190,141,249,82,
232,50,21,84,215,242,180,198,168,167,103,122,152,162,145,184,
43,237,119,183,7,12,125,55,252,206,235,160,140,133,179,192,
110,176,221,134,19,6,187,59,26,129,112,73,175,45,24,218,
44,66,151,32,137,31,35,147,236,247,117,132,79,136,154,105,
199,101,203,52,57,4,153,197,88,76,202,174,233,62,208,91,
231,53,1,124,0,28,142,170,158,51,226,65,123,186,239,246,
38,56,36,108,8,126,9,189,81,234,212,224,13,3,40,64,
172,74,181,118,39,227,130,89,245,166,16,61,106,196,211,107,
229,195,138,18,93,207,240,95,58,255,209,217,15,111,46,173,
223,42,115,238,139,243,23,98,100,178,37,97,191,213,222,155,
165,2,146,204,120,241,163,128,22,90,60,185,67,34,27,248,
164,69,41,230,104,47,144,251,20,17,150,225,254,161,102,70
]

# S-box 81 (Table 6)
SBOX_81 = [
99,32,150,197,205,1,48,101,96,97,82,18,158,57,52,218,
226,147,54,108,175,212,219,85,157,237,26,5,156,179,235,24,
163,74,27,13,201,231,176,75,81,255,236,25,63,190,44,148,
28,253,112,204,139,102,80,53,200,113,11,9,39,65,222,14,
3,223,247,19,95,124,0,130,98,214,117,146,138,69,35,58,
46,144,45,142,164,6,10,76,77,174,141,78,196,109,152,159,
220,22,120,227,234,33,180,118,67,123,181,244,250,51,72,224,
182,86,62,140,87,208,2,40,21,239,38,232,233,210,129,68,
7,126,61,194,125,42,15,12,41,103,184,127,134,229,199,167,
183,71,185,143,60,94,207,105,151,90,36,216,23,49,155,106,
145,248,154,215,16,132,149,169,128,8,209,47,131,178,160,93,
116,122,133,168,20,161,245,172,228,83,100,107,202,137,73,79,
188,17,217,111,186,43,119,177,243,195,66,110,136,89,189,241,
115,171,59,30,92,249,252,230,251,29,31,104,162,84,246,4,
221,55,173,165,153,242,192,254,121,34,238,191,211,135,198,91,
88,206,37,50,193,56,166,213,114,225,187,170,70,203,240,64
]

# S-box 111 (Table 7)
SBOX_111 = [
99,218,45,232,214,229,166,243,43,236,32,209,19,95,185,253,
71,245,54,10,80,83,58,119,91,46,239,250,156,13,190,96,
113,98,40,196,201,159,69,165,104,221,233,167,207,235,251,162,
127,82,87,17,183,187,175,126,14,144,84,219,141,20,226,140,
106,37,227,22,198,118,34,78,164,220,143,50,112,11,146,23,
116,189,60,111,38,178,147,242,53,151,39,125,47,205,131,212,
109,206,105,128,121,29,90,199,155,33,157,171,5,238,237,200,
213,63,8,224,248,76,173,228,134,161,74,246,49,195,6,204,
117,249,64,191,177,107,75,3,35,124,123,62,81,16,103,110,
18,132,188,168,135,1,89,210,234,30,197,114,9,97,203,154,
122,138,12,27,94,222,101,192,193,28,139,179,137,202,57,73,
72,230,25,7,65,254,108,24,215,231,52,93,129,56,42,186,
100,153,181,66,244,172,0,130,252,120,92,133,255,86,163,115,
31,79,208,240,142,77,149,88,194,184,55,21,182,176,36,61,
170,241,223,225,68,59,48,26,174,85,102,44,4,150,160,217,
145,158,2,41,247,152,169,148,216,15,51,136,67,70,180,211
]

# S-box 128 (Table 8)
SBOX_128 = [
99,158,120,142,11,56,149,192,178,2,206,226,253,160,87,19,
139,10,54,245,80,53,163,221,44,29,103,250,156,28,190,6,
23,64,215,127,201,249,205,240,31,119,173,182,3,235,217,25,
196,22,185,187,132,17,175,231,121,9,220,189,141,20,209,174,
89,97,242,82,57,254,136,177,211,84,203,186,52,214,79,113,
184,219,105,246,4,43,108,227,83,224,39,130,62,69,94,77,
176,32,60,59,14,46,15,26,117,237,191,35,5,68,33,234,
110,12,179,151,188,247,233,27,241,124,61,111,223,150,96,102,
155,159,98,157,78,122,30,207,171,161,72,47,115,152,239,213,
222,183,248,70,210,137,106,135,200,75,92,114,144,37,143,86,
107,100,63,228,131,18,169,243,208,13,71,8,1,172,198,88,
123,93,162,67,65,118,147,129,40,126,112,230,24,229,145,50,
138,51,194,36,41,202,170,125,48,45,197,148,85,154,58,81,
104,146,193,165,232,212,166,73,181,116,21,55,167,109,66,74,
0,134,49,180,238,128,252,199,140,255,204,91,38,195,95,251,
42,218,236,244,76,16,101,133,216,90,153,34,7,168,225,164
]

# Dictionary of all S-boxes
ALL_SBOXES = {
    'S-box 4': SBOX_4,
    'S-box 44': SBOX_44,
    'S-box 81': SBOX_81,
    'S-box 111': SBOX_111,
    'S-box 128': SBOX_128
}

# -------------------------
# 2) Build inverse S-boxes
# -------------------------
def build_inv_sbox(sbox: List[int]) -> List[int]:
    inv = [0] * 256
    for i, v in enumerate(sbox):
        inv[v] = i
    return inv

ALL_INV_SBOXES = {name: build_inv_sbox(sbox) for name, sbox in ALL_SBOXES.items()}

# -------------------------
# 3) AES constants & GF mul
# -------------------------
RCON = [0x00, 0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36]

def xtime(a: int) -> int:
    return ((a << 1) ^ 0x1B) & 0xFF if (a & 0x80) else (a << 1) & 0xFF

def gf_mul(a: int, b: int) -> int:
    res = 0
    while b:
        if b & 1:
            res ^= a
        a = xtime(a)
        b >>= 1
    return res & 0xFF

# -------------------------
# 4) Key expansion
# -------------------------
def sub_word(word: List[int], sbox) -> List[int]:
    return [sbox[b] for b in word]

def rot_word(word: List[int]) -> List[int]:
    return word[1:] + word[:1]

def key_expansion(key_bytes: bytes, sbox) -> List[List[int]]:
    assert len(key_bytes) == 16
    Nk, Nr, Nb = 4, 10, 4
    w = [list(key_bytes[i:i+4]) for i in range(0, 16, 4)]
    for i in range(Nk, Nb*(Nr+1)):
        temp = w[i-1].copy()
        if i % Nk == 0:
            temp = sub_word(rot_word(temp), sbox)
            temp[0] ^= RCON[i//Nk]
        wi = [(w[i-Nk][j] ^ temp[j]) & 0xFF for j in range(4)]
        w.append(wi)
    round_keys = []
    for r in range(Nr+1):
        rk = []
        for c in range(4):
            rk += w[4*r + c]
        round_keys.append(rk)
    return round_keys

# -------------------------
# 5) Core AES operations
# -------------------------
def add_round_key(state: List[int], rk: List[int]):
    for i in range(16):
        state[i] ^= rk[i]

def sub_bytes(state: List[int], sbox):
    for i in range(16):
        state[i] = sbox[state[i]]

def inv_sub_bytes(state: List[int], inv_sbox):
    for i in range(16):
        state[i] = inv_sbox[state[i]]

def shift_rows(state: List[int]):
    tmp = state.copy()
    state[1], state[5], state[9], state[13] = tmp[5], tmp[9], tmp[13], tmp[1]
    state[2], state[6], state[10], state[14] = tmp[10], tmp[14], tmp[2], tmp[6]
    state[3], state[7], state[11], state[15] = tmp[15], tmp[3], tmp[7], tmp[11]

def inv_shift_rows(state: List[int]):
    tmp = state.copy()
    state[1], state[5], state[9], state[13] = tmp[13], tmp[1], tmp[5], tmp[9]
    state[2], state[6], state[10], state[14] = tmp[10], tmp[14], tmp[2], tmp[6]
    state[3], state[7], state[11], state[15] = tmp[7], tmp[11], tmp[15], tmp[3]

def mix_single_column(a: List[int]):
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ gf_mul(a[0] ^ a[1], 0x02)
    a[1] ^= t ^ gf_mul(a[1] ^ a[2], 0x02)
    a[2] ^= t ^ gf_mul(a[2] ^ a[3], 0x02)
    a[3] ^= t ^ gf_mul(a[3] ^ u, 0x02)

def mix_columns(state: List[int]):
    for c in range(4):
        col = [state[4*c + r] for r in range(4)]
        mix_single_column(col)
        for r in range(4):
            state[4*c + r] = col[r]

def inv_mix_columns(state: List[int]):
    for c in range(4):
        s0, s1, s2, s3 = state[4*c:4*c+4]
        state[4*c+0] = (gf_mul(s0,0x0e) ^ gf_mul(s1,0x0b) ^ gf_mul(s2,0x0d) ^ gf_mul(s3,0x09)) & 0xFF
        state[4*c+1] = (gf_mul(s0,0x09) ^ gf_mul(s1,0x0e) ^ gf_mul(s2,0x0b) ^ gf_mul(s3,0x0d)) & 0xFF
        state[4*c+2] = (gf_mul(s0,0x0d) ^ gf_mul(s1,0x09) ^ gf_mul(s2,0x0e) ^ gf_mul(s3,0x0b)) & 0xFF
        state[4*c+3] = (gf_mul(s0,0x0b) ^ gf_mul(s1,0x0d) ^ gf_mul(s2,0x09) ^ gf_mul(s3,0x0e)) & 0xFF

# -------------------------
# 6) AES Encrypt / Decrypt
# -------------------------
def aes_encrypt_block(plaintext16: bytes, round_keys: List[List[int]], sbox) -> bytes:
    assert len(plaintext16) == 16
    state = list(plaintext16)[:]
    add_round_key(state, round_keys[0])
    for rnd in range(1,10):
        sub_bytes(state, sbox)
        shift_rows(state)
        mix_columns(state)
        add_round_key(state, round_keys[rnd])
    sub_bytes(state, sbox)
    shift_rows(state)
    add_round_key(state, round_keys[10])
    return bytes(state)

def aes_decrypt_block(cipher16: bytes, round_keys: List[List[int]], inv_sbox) -> bytes:
    assert len(cipher16) == 16
    state = list(cipher16)[:]
    add_round_key(state, round_keys[10])
    for rnd in range(9,0,-1):
        inv_shift_rows(state)
        inv_sub_bytes(state, inv_sbox)
        add_round_key(state, round_keys[rnd])
        inv_mix_columns(state)
    inv_shift_rows(state)
    inv_sub_bytes(state, inv_sbox)
    add_round_key(state, round_keys[0])
    return bytes(state)

# -------------------------
# 7) Padding & ECB mode
# -------------------------
def pkcs7_pad(data: bytes) -> bytes:
    pad_len = 16 - (len(data) % 16)
    return data + bytes([pad_len])*pad_len

def pkcs7_unpad(data: bytes) -> bytes:
    if not data: return data
    pad = data[-1]
    if pad < 1 or pad > 16:
        raise ValueError("Invalid padding")
    return data[:-pad]

def aes_ecb_encrypt(data: bytes, key: bytes, sbox_name: str = 'S-box 44') -> bytes:
    sbox = ALL_SBOXES[sbox_name]
    rk = key_expansion(key, sbox)
    data_p = pkcs7_pad(data)
    out = b""
    for i in range(0, len(data_p), 16):
        blk = data_p[i:i+16]
        out += aes_encrypt_block(blk, rk, sbox)
    return out

def aes_ecb_decrypt(data: bytes, key: bytes, sbox_name: str = 'S-box 44') -> bytes:
    sbox = ALL_SBOXES[sbox_name]
    inv_sbox = ALL_INV_SBOXES[sbox_name]
    rk = key_expansion(key, sbox)
    out = b""
    for i in range(0, len(data), 16):
        blk = data[i:i+16]
        out += aes_decrypt_block(blk, rk, inv_sbox)
    return pkcs7_unpad(out)

# ===========================
# CRYPTOGRAPHIC ANALYSIS
# ===========================

def hamming_weight(x: int) -> int:
    """Count number of 1s in binary representation"""
    return bin(x).count('1')

def hamming_distance(x: int, y: int) -> int:
    """Hamming distance between two integers"""
    return hamming_weight(x ^ y)

# -------------------------
# 1) Nonlinearity (NL)
# -------------------------
def walsh_hadamard_transform(f: List[int]) -> List[int]:
    """Walsh-Hadamard Transform for boolean function"""
    n = len(f)
    wht = f.copy()
    h = 1
    while h < n:
        for i in range(0, n, h * 2):
            for j in range(i, i + h):
                x = wht[j]
                y = wht[j + h]
                wht[j] = x + y
                wht[j + h] = x - y
        h *= 2
    return wht

def compute_nonlinearity(sbox: List[int]) -> float:
    """Compute nonlinearity of S-box"""
    n = 8
    nl_values = []

    for bit in range(8):
        # Extract bit function
        f = [(sbox[x] >> bit) & 1 for x in range(256)]
        # Convert to {-1, 1}
        f_pm = [1 - 2*b for b in f]
        # Compute WHT
        wht = walsh_hadamard_transform(f_pm)
        # Max absolute value
        max_wht = max(abs(w) for w in wht)
        # Nonlinearity for this bit
        nl_bit = (2**(n-1)) - (max_wht / 2)
        nl_values.append(nl_bit)

    return min(nl_values)

# -------------------------
# 2) Strict Avalanche Criterion (SAC)
# -------------------------
def compute_sac(sbox: List[int]) -> float:
    """Compute SAC value"""
    n = 8
    sac_matrix = np.zeros((n, n))

    for x in range(256):
        for i in range(n):
            x_flipped = x ^ (1 << i)
            y1 = sbox[x]
            y2 = sbox[x_flipped]
            diff = y1 ^ y2

            for j in range(n):
                if (diff >> j) & 1:
                    sac_matrix[i][j] += 1

    sac_matrix /= 256
    return float(np.mean(sac_matrix))

# -------------------------
# 3) BIC-NL (Bit Independence Criterion - Nonlinearity)
# -------------------------
def compute_bic_nl(sbox: List[int]) -> float:
    """Compute BIC-NL"""
    n = 8
    nl_values = []

    for i, j in combinations(range(n), 2):
        # XOR of two output bits
        f = [((sbox[x] >> i) & 1) ^ ((sbox[x] >> j) & 1) for x in range(256)]
        f_pm = [1 - 2*b for b in f]
        wht = walsh_hadamard_transform(f_pm)
        max_wht = max(abs(w) for w in wht)
        nl_bit = (2**(n-1)) - (max_wht / 2)
        nl_values.append(nl_bit)

    return min(nl_values) if nl_values else 0

# -------------------------
# 4) BIC-SAC
# -------------------------
def compute_bic_sac(sbox: List[int]) -> float:
    """Compute BIC-SAC"""
    n = 8
    bic_values = []

    for i, j in combinations(range(n), 2):
        count = 0
        for x in range(256):
            for k in range(n):
                x_flipped = x ^ (1 << k)
                y1 = sbox[x]
                y2 = sbox[x_flipped]

                bit_i_changed = ((y1 >> i) & 1) != ((y2 >> i) & 1)
                bit_j_changed = ((y1 >> j) & 1) != ((y2 >> j) & 1)

                if bit_i_changed != bit_j_changed:
                    count += 1

        bic_values.append(count / (256 * n))

    return float(np.mean(bic_values)) if bic_values else 0

# -------------------------
# 5) Linear Approximation Probability (LAP)
# -------------------------
def compute_lap(sbox: List[int]) -> float:
    """Compute LAP"""
    max_bias = 0

    for input_mask in range(1, 256):
        for output_mask in range(1, 256):
            count = 0
            for x in range(256):
                input_parity = hamming_weight(x & input_mask) % 2
                output_parity = hamming_weight(sbox[x] & output_mask) % 2
                if input_parity == output_parity:
                    count += 1

            bias = abs(count - 128) / 256
            max_bias = max(max_bias, bias)

    return max_bias

# -------------------------
# 6) Differential Approximation Probability (DAP)
# -------------------------
def compute_dap(sbox: List[int]) -> float:
    """Compute DAP (Differential Uniformity)"""
    max_count = 0

    for delta_in in range(1, 256):
        for delta_out in range(256):
            count = 0
            for x in range(256):
                if sbox[x] ^ sbox[x ^ delta_in] == delta_out:
                    count += 1
            max_count = max(max_count, count)

    return max_count / 256

# -------------------------
# 7) Differential Uniformity (DU)
# -------------------------
def compute_differential_uniformity(sbox: List[int]) -> int:
    """Compute Differential Uniformity"""
    max_count = 0

    for delta_in in range(1, 256):
        for delta_out in range(256):
            count = 0
            for x in range(256):
                if sbox[x] ^ sbox[x ^ delta_in] == delta_out:
                    count += 1
            max_count = max(max_count, count)

    return max_count

# -------------------------
# 8) Algebraic Degree (AD)
# -------------------------
def anf_transform(truth_table: List[int]) -> List[int]:
    """Compute ANF (Algebraic Normal Form) using Mobius transform"""
    n = len(truth_table)
    anf = truth_table.copy()

    i = 1
    while i < n:
        for j in range(n):
            if j & i == 0:
                anf[j + i] ^= anf[j]
        i <<= 1

    return anf

def compute_algebraic_degree(sbox: List[int]) -> int:
    """Compute algebraic degree of S-box"""
    max_degree = 0

    for bit in range(8):
        truth_table = [(sbox[x] >> bit) & 1 for x in range(256)]
        anf = anf_transform(truth_table)

        # Find maximum Hamming weight in ANF coefficients
        for i, coef in enumerate(anf):
            if coef == 1:
                degree = hamming_weight(i)
                max_degree = max(max_degree, degree)

    return max_degree

# -------------------------
# 9) Transparency Order (TO)
# -------------------------
def compute_transparency_order(sbox: List[int]) -> Tuple[float, float]:
    """Compute Transparency Order (average and variance)"""
    n = 8
    transparencies = []

    for a in range(1, 256):
        for b in range(1, 256):
            max_diff = 0
            for delta in range(1, 256):
                count = 0
                for x in range(256):
                    if (x & a) == a:
                        diff_x = sbox[x] ^ sbox[x ^ delta]
                        if (diff_x & b) == b:
                            count += 1

                abs_diff = abs(count - 128/hamming_weight(b))
                max_diff = max(max_diff, abs_diff)

            transparencies.append(max_diff)

    avg_to = float(np.mean(transparencies))
    var_to = float(np.var(transparencies))

    return avg_to, var_to

# -------------------------
# 10) Correlation Immunity (CI)
# -------------------------
def is_balanced(f: List[int]) -> bool:
    """Check if boolean function is balanced"""
    return sum(f) == len(f) // 2

def compute_correlation_immunity(sbox: List[int]) -> int:
    """Compute correlation immunity order"""
    n = 8
    max_ci = 0

    for bit in range(8):
        f = [(sbox[x] >> bit) & 1 for x in range(256)]

        if not is_balanced(f):
            continue

        # Check correlation immunity order
        ci_order = 0
        for k in range(1, n):
            all_balanced = True
            for subset in combinations(range(n), k):
                # Project function onto subset
                projected = [0] * (2**k)
                for x in range(256):
                    idx = 0
                    for i, bit_pos in enumerate(subset):
                        if (x >> bit_pos) & 1:
                            idx |= (1 << i)
                    projected[idx] ^= f[x]

                if not is_balanced(projected):
                    all_balanced = False
                    break

            if all_balanced:
                ci_order = k
            else:
                break

        max_ci = max(max_ci, ci_order)

    return max_ci

# -------------------------
# Evaluate All S-boxes
# -------------------------
def evaluate_sbox(sbox: List[int], name: str) -> Dict:
    """Evaluate a single S-box with all criteria"""
    print(f"\nEvaluating {name}...")

    results = {
        'Name': name,
        'NL': compute_nonlinearity(sbox),
        'SAC': compute_sac(sbox),
        'BIC-NL': compute_bic_nl(sbox),
        'BIC-SAC': compute_bic_sac(sbox),
        'LAP': compute_lap(sbox),
        'DAP': compute_dap(sbox),
        'DU': compute_differential_uniformity(sbox),
        'AD': compute_algebraic_degree(sbox)
    }

    # TO computation can be slow, simplified version
    # results['TO-Avg'], results['TO-Var'] = compute_transparency_order(sbox)

    # CI computation
    # results['CI'] = compute_correlation_immunity(sbox)

    return results

def evaluate_all_sboxes():
    """Evaluate all S-boxes and display results"""
    print("="*80)
    print("CRYPTOGRAPHIC EVALUATION OF ALL S-BOXES")
    print("="*80)

    all_results = []

    for name, sbox in ALL_SBOXES.items():
        result = evaluate_sbox(sbox, name)
        all_results.append(result)

    # Display results in table format
    print("\n" + "="*80)
    print("EVALUATION RESULTS")
    print("="*80)

    criteria = ['NL', 'SAC', 'BIC-NL', 'BIC-SAC', 'LAP', 'DAP', 'DU', 'AD']

    # Header
    print(f"{'S-box':<15}", end="")
    for criterion in criteria:
        print(f"{criterion:>12}", end="")
    print()
    print("-"*80)

    # Data rows
    for result in all_results:
        print(f"{result['Name']:<15}", end="")
        for criterion in criteria:
            value = result[criterion]
            if isinstance(value, float):
                print(f"{value:>12.6f}", end="")
            else:
                print(f"{value:>12}", end="")
        print()

    print("="*80)

    # Best S-box analysis
    print("\nBEST PERFORMING S-BOX:")
    print("-"*80)

    # Calculate overall score (lower is better for most metrics)
    for result in all_results:
        score = (120 - result['NL']) + abs(0.5 - result['SAC']) + \
                (120 - result['BIC-NL']) + abs(0.5 - result['BIC-SAC'])
        result['Score'] = score

    best_sbox = min(all_results, key=lambda x: x['Score'])
    print(f"Best S-box: {best_sbox['Name']} with score: {best_sbox['Score']:.6f}")
    print("(Lower score is better)")
    print("="*80)

    return all_results

# -------------------------
# Demo
# -------------------------
if __name__ == "__main__":
    KEY = b"\x55\x33\x67\xfd\xaa\x10\x7a\xfd\xec\xf3\x15\xa7\xf6\x2a\x57\x58"
    PLAINTEXT = b"fernandodinars"

    print("="*80)
    print("AES ENCRYPTION/DECRYPTION WITH MULTIPLE S-BOXES")
    print("="*80)

    # Test encryption/decryption with each S-box
    print("\nENCRYPTION/DECRYPTION TEST:")
    print("-"*80)

    for sbox_name in ALL_SBOXES.keys():
        print(f"\nUsing {sbox_name}:")
        ct = aes_ecb_encrypt(PLAINTEXT, KEY, sbox_name)
        print(f"  Ciphertext: {ct.hex()}")

        pt = aes_ecb_decrypt(ct, KEY, sbox_name)
        print(f"  Decrypted:  {pt}")
        print(f"  Match: {'✓' if pt == PLAINTEXT else '✗'}")

    # Evaluate all S-boxes
    print("\n")
    results = evaluate_all_sboxes()

    print("\n✓ All tests completed!")